import { Project as b, VariableDeclarationKind as w } from "ts-morph";
const S = (a) => a.toLowerCase().split("-").map((r) => r.charAt(0).toUpperCase() + r.slice(1)).join(""), I = (a) => a.replace(/-([a-z])/g, (r, i) => i.toUpperCase()), v = (a) => I(`on-${a}`), C = ({
  components: a,
  stencilPackageName: r,
  customElementsDir: i,
  defaultExport: f = !1,
  useClient: d = !1
}) => {
  const u = new b({ useInMemoryFileSystem: !0 }), o = d ? `'use client';

` : "", t = u.createSourceFile(
    "component.ts",
    `${o}/**
 * This file was automatically generated by the Stencil React Output Target.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 */

/* eslint-disable */

import React from 'react';
import { createComponent } from '@stencil/react-output-target/runtime';
import type { EventName } from '@stencil/react-output-target/runtime';
  `
  );
  for (const s of a) {
    const m = s.tagName, n = S(m), p = `${n}Element`, y = `${n}CustomEvent`;
    t.addImportDeclaration({
      moduleSpecifier: `${r}/${i}/${m}.js`,
      namedImports: [
        {
          name: n,
          alias: p
        },
        {
          name: "defineCustomElement",
          alias: `define${n}`
        }
      ]
    });
    const N = (s.events || []).filter((e) => e.internal === !1), g = [];
    for (const e of N)
      if (Object.keys(e.complexType.references).length > 0) {
        for (const h of Object.keys(e.complexType.references))
          e.complexType.references[h].location === "global" || t.addImportDeclaration({
            moduleSpecifier: r,
            namedImports: [
              {
                name: h,
                isTypeOnly: !0
              }
            ]
          });
        t.addImportDeclaration({
          moduleSpecifier: r,
          namedImports: [
            {
              name: y,
              isTypeOnly: !0
            }
          ]
        }), g.push({
          originalName: e.name,
          name: v(e.name),
          type: `EventName<${y}<${e.complexType.original}>>`
        });
      } else
        g.push({
          originalName: e.name,
          name: v(e.name),
          type: `EventName<CustomEvent<${e.complexType.original}>>`
        });
    const E = `${n}Events`;
    t.addTypeAlias({
      name: E,
      type: g.length > 0 ? `{ ${g.map((e) => `${e.name}: ${e.type}`).join(`,
`)} }` : "NonNullable<unknown>"
    });
    const F = t.addVariableStatement({
      declarationKind: w.Const,
      // React as never is a hack to by-pass a @types/react issue.
      declarations: [
        {
          name: n,
          initializer: `/*@__PURE__*/ createComponent<${p}, ${E}>({
          tagName: '${m}',
          elementClass: ${p},
          react: React,
          events: { ${g.map((e) => `${e.name}: '${e.originalName}'`).join(`,
`)}} as ${E},
          defineCustomElement: define${n}
        })`
        }
      ]
    });
    f ? t.addExportAssignment({
      isExportEquals: !1,
      expression: n
    }) : F.setIsExported(!0);
  }
  return t.organizeImports(), t.formatText(), t.getFullText();
}, _ = async ({
  stencilPackageName: a,
  components: r,
  outDir: i,
  customElementsDir: f,
  esModules: d,
  experimentalUseClient: u,
  excludeComponents: o,
  project: l
}) => {
  const c = [], t = r.filter((s) => !(s.internal === !0 || o != null && o.includes(s.tagName)));
  if (t.length === 0)
    return [];
  if (d === !0)
    for (const s of t) {
      const m = S(s.tagName), n = `${i}/${m}.ts`, p = C({
        components: [s],
        stencilPackageName: a,
        customElementsDir: f,
        defaultExport: !0,
        useClient: u
      }), y = l.createSourceFile(n, p, { overwrite: !0 });
      c.push(y);
    }
  else {
    const s = `${i}/components.ts`, m = C({
      components: t,
      stencilPackageName: a,
      customElementsDir: f,
      defaultExport: !1,
      useClient: u
    }), n = l.createSourceFile(s, m, { overwrite: !0 });
    await n.save(), c.push(n);
  }
  return c;
}, $ = "react-output-target", x = "components", T = "dist-custom-elements", R = ({
  outDir: a,
  esModules: r,
  stencilPackageName: i,
  experimentalUseClient: f,
  excludeComponents: d
}) => {
  let u = x;
  return {
    type: "custom",
    name: $,
    validate(o) {
      const l = (o.outputTargets || []).find(
        (c) => c.type === T
      );
      if (l == null)
        throw new Error(
          `The '${$}' requires '${T}' output target. Add { type: '${T}' }, to the outputTargets config.`
        );
      if (l.dir !== void 0 && (u = l.dir), i === void 0) {
        if (o.sys && o.packageJsonFilePath) {
          const { name: c } = JSON.parse(o.sys.readFileSync(o.packageJsonFilePath, "utf8"));
          i = c;
        }
        if (!i)
          throw new Error(
            `Unable to find the package name in the package.json file: ${o.packageJsonFilePath}. Please provide the stencilPackageName manually to the ${$} output target.`
          );
      }
    },
    async generator(o, l, c) {
      const t = c.createTimeSpan(`generate ${$} started`, !0), s = c.components, m = new b(), n = await _({
        outDir: a,
        components: s,
        stencilPackageName: i,
        customElementsDir: u,
        esModules: r === !0,
        experimentalUseClient: f === !0,
        excludeComponents: d,
        project: m
      });
      await Promise.all(
        n.map((p) => l.fs.writeFile(p.getFilePath(), p.getFullText()))
      ), t.finish(`generate ${$} finished`);
    }
  };
};
export {
  R as reactOutputTarget
};
